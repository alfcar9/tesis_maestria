---
title: "TSP_toto"
author: "Alfredo Carrillo"
date: "February 16, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(gridExtra)
```

# Functions
```{r}
# Define Euclidean distance funcion
dist_euclidean <- function(i, j){
  result <- (i-j)^2 %>% sum() %>% sqrt()
  return(result)
}
# Given set of coordiantes calculates euclidean distance and adds noice.
matrix_euclidean <- function(matrix_pos){
  matrix_dist <- matrix(integer(n^2), ncol = n)
  for(i in 1:(n-1)){
    i_vec <- matrix_pos[i,]
    for(j in (i+1):n){
      j_vec <- matrix_pos[j,]
      matrix_dist[i,j] <- dist_euclidean(i_vec, j_vec)  %>% round(2)
      matrix_dist[j,i] <- matrix_dist[i,j]
    }
  }
  return(matrix_dist)
}

# Hace simétrica la matrix
matrix_symmetric <- function(matrix){
  for(i in 1:(n-1)){
    for(j in (i+1):n){
        if(matrix[i,j] != matrix[j,i]){
          if(matrix[i,j] < matrix[j,i]){
            matrix[j,i] <- matrix[i,j]
          }
          else{
            matrix[i,j] <- matrix[j,i]
          }
        }
     }
  }
  return(matrix)
}

# Updates distance matrix when triangle Inequality is not satissfied
desigualdad_triangulo <- function(cities_dist)
  for(i in 1:(n-1)){
    for(j in (i+1):n){
      distancia_minima <- cities_dist[i,j]
      set <- setdiff(1:n, c(i,j))
      for(k in set){
        distancia_indirecta <- cities_dist[i,k] + cities_dist[k,j]
        if(distancia_indirecta < distancia_minima){
          distancia_minima <- distancia_minima
        }
      }
      cities_dist[i,j] <- distancia_minima
      cities_dist[j,i] <- distancia_minima
    }
    return(cities_dist)
  }
TSP_plot <- function(cities_pos_df, camino_heuristica, camino_heuristica_original){
  n <- nrow(cities_pos_df)
  g <- ggplot(cities_pos_df, aes(x = V1, y = V2)) + geom_point() + theme_bw() + geom_text(aes(label=c(1:n)), hjust=0, vjust=0)
  if(all(!camino_heuristica==0)){
    m <- n
  }
  else{
   m <- min(which(camino_heuristica==0))-2 
  }
  for(i in 1:m){
     i_vec <- flatten_dbl(cities_pos_df[camino_heuristica[i],])
     j_vec <- flatten_dbl(cities_pos_df[camino_heuristica[i+1],])
     if(camino_heuristica[i] == camino_heuristica_original[i]){
        g <- g + geom_segment(x = i_vec[1], xend = j_vec[1], y = i_vec[2], yend = j_vec[2], color="black")
     }
     else{
       g <- g + geom_segment(x = i_vec[1] , xend = j_vec[1], y = i_vec[2], yend = j_vec[2], color="red") 
     }
  }
  return(g)
}

index_function <- function(i,j){
  return(which(paths[i,]==j)[1])
}
```

# Hyper parameters
```{r}
set.seed(11212)
proportion_edges <- 1/2 # Each node will only have this proportion of neighbors with respect the n neighbors
greedy <- 3 # When a node has this number of neighbors then it adds to the path regardless of the cost
```

# Main
```{r}
######################################## LEER ARCHIVO
instancia <- read_table2("~/Desktop/Tesis_Maestria/tesis_maestria/d198.tsp", skip = 4)
n <- nrow(instancia)
cities_pos <- instancia[2:(n-1),2:3]
n <- n-2
######################################## GENERAR matrix ALEATORIA
# n <- 75
# cities_pos <- matrix(runif(2*n), ncol = 2) # Generate coordinates of n neighbors randomly
# cities_pos <- round(1000*(cities_pos)) # Round to integers
#################################################################
cities_pos <- as.matrix(cities_pos)
colnames(cities_pos) <- c("V1", "V2")
cities_dist_original <- matrix_euclidean(cities_pos) # Generate distance matrix
cities_dist <- cities_dist_original # For last iteration, save original values
```

```{r}
# Eliminate all but the first kth nearest edges for each node.
total_neighbors <- floor(n*proportion_edges) # Number of the first kth neighbors, the rest edges will get eliminated
# Eliminate all but the first kth nearest edges for each node.
for(i in 1:n){
  kth_near <- (cities_dist_original[i,] %>% sort())[total_neighbors]
  for(j in 1:n){
      if(cities_dist_original[i,j] > kth_near){
        cities_dist[i,j] <- Inf
      }
   }
}

# It is possible that the resulting matrix is not symmetric because there is no symmetry in the fact that 
# the kth neighbor v2 for a v1 node might not be the kth neighbor v1 for v2.
cities_dist <- matrix_symmetric(cities_dist)


# We define a list that has the neighbors of each node. Because each node can have different amount of neighbors a matrix
# is not an appropriate structure.
neighbors_list <- list()
for(i in 1:n){
  neighbors_list[[i]] <- which(as.logical((cities_dist[i,] < Inf)*(cities_dist[i,] > 0) %>% as.integer()))
}
# Estricturas a usar
paths <- matrix(integer((n+1)*n), nrow = n) # The Paths starting at each node. In each row we try to form a cycle.
paths[,c(1,(n+1))] <- 1:n
costs <- matrix(integer(n^2), nrow = n) # The cost of traveling from [i,j] to [i,j+1]
# Vector con numero de neighbors
degree_neighbors <- sapply(1:n, function(i){neighbors_list[[i]] %>% length()}) #Number of neighbors of each node
degree_neighbors_list <- list() # For each cycle we need to keep control of how many neighbors are left. We define a list.
for(i in 1:n){
  degree_neighbors_list[[i]] <- degree_neighbors
}
```

#Iteraciones
```{r}
# Primero generamos un cycle hamiltoniano para cada nodo.
m <- n-1 # Si se quiere ver como se ve el camino en la m-ésima iteracion se puede ajustar, sino dejar m = n-1
for(num_iter in 1:m){
    for(i in 1:n){
      city_current <- paths[i, num_iter]
      # Se calculan las ciudades vecinas que no se han visitado
      cities_neighbors_to_go <- setdiff(neighbors_list[[city_current]], paths[i, 1:num_iter])
      number_neighbors <- length(cities_neighbors_to_go)
      # Si no hay ciudades vecinas entonces se hace el calculo sobre todas las posibles ciudades
      if(number_neighbors == 0){
        cities_neighbors_to_go <- setdiff(1:n, paths[i, 1:num_iter])
      }
      # Se guardan en un vector solo los grados de los correspondientes nodos por visitar
      degree_neighbors_to_go <- degree_neighbors_list[[i]][cities_neighbors_to_go]
      # Se calcula un valor booleano que previene que nos olvidemos de un nodo. Si existe un nodo con pocos
      # vecinos hay que visitarlo inmediatamente, sino, conviene visitar el más proximo.
      immediate_neighbors <- degree_neighbors_to_go <= greedy
      if(all(!immediate_neighbors)){
        # En caso de que todos los nodos tengan multiples vecinos calcular el mas proximo
        city_distances <- cities_dist_original[city_current, cities_neighbors_to_go]
        dist_min <- min(city_distances)
        city_min <- cities_neighbors_to_go[which.min(city_distances)]
      }
      else{
      # En caso de que haya que visitar uno inmediatamente entonces añadirlo 
        city_min <- cities_neighbors_to_go[which.min(degree_neighbors_to_go)]
        dist_min <- cities_dist_original[city_current, city_min]
      }
      # Todos los vecinos que tengan asociado a la ciudad que se visita se les resta un grado
      if(number_neighbors!=0){
         degree_neighbors_list[[i]][cities_neighbors_to_go] <- degree_neighbors_list[[i]][cities_neighbors_to_go] - 1  
      }
      # Se actualiza el grado de la ciudad actual a 0.
      degree_neighbors_list[[i]][city_current] <- 0
      # Se actualiza la matriz de costo.
      costs[i, num_iter] <- dist_min
      paths[i, num_iter+1] <- city_min
  }
}
# Se hace el costo de cerrar el ciclo.
if(m == n-1){
  costs[1:n, n]  <- sapply(1:n, function(i){cities_dist_original[paths[i, n], i]})
}
# Se calcula el costo de cada ciclo
costs_cycles <- sapply(1:n, function(i){sum(costs[i,])})
# Es el indice del mejor ciclo
cycle_index <- which.min(costs_cycles)
# Se guarda el mejor ciclo y su costo
path_min_noswap <- paths[cycle_index,]
cost_min_noswap <- costs_cycles[cycle_index]
```

```{r}
# Matriz que a cada fila corresponde un ciclo. Cada celda guarda que numero de visita es cada ciudad. Si en [1,2] = 13, entonces la 13ava ciudad visitada
# en el ciclo 1 es la ciudad 2. 
index_matrix <- matrix(0L, nrow = n, ncol = n)
# Se generan los caminos extendidos para poder considerar en una sola matriz todos los caminos posibles leidos como secuencia
paths_ext <- matrix(0L, nrow = n, ncol = 2*n)
# Lo análogo con la funcion de costos
costs_ext <- matrix(0L, nrow = n, ncol = 2*n)
# Se generan estas estructuras
for(i in 1:n){
  index_matrix[i,] <- sapply(1:n, function(j) index_function(i,j))
  paths_ext[i,] <-  c(paths[i,], paths[i,2:n])
  costs_ext[i,] <-  c(costs[i,], costs[i,])
}
```

```{r}
exito <- 1 # Indica que se encontró alguna estructura que swapear, se define 1 para que entre al while al menos una vez
while(exito>0){
  exito <- 0  # no se han encontrado estructuras swapeables
  structure_list <- list() # se guardan las estructuras swapeables
  structure_index_list <- list()  # se guarda donde inicia la estrucutra
  structure_cost_vector <- c() # se guarda el costo total de cada estructura
  for(len in 3:(n-1)){  # se fija una longitud
    ini <- 1            # comenzando en el primer nodo
    end <- len+1        # hasta el nodo len + 1 se hace lo siguiente 
    for(path in 1:n){   # para cada longitud existen siempre n paths posibles por revisar
      structure <- paths_ext[cycle_index, ini:end] # se guarda la secuencia de ciudades
      structure_cost <- sum(costs_ext[cycle_index, ini:(end-1)]) # el costo de las transiciones
      structure_length <- len + 1 # la longitud del vector que esta dada por len + 1
      extreme1 <- structure[1] # se guardan los extremos, la cabeza
      extreme2 <- tail(structure, 1) # y la cola
      for(k in setdiff(1:n, cycle_index)){# vamos a buscar esta estructura en cada uno de los posibles caminos
        index_begin <- index_matrix[k,extreme1] # obtenemos el indice donde se visita al extremo 1
        index_end <- index_matrix[k,extreme2] # y el indice donde se visita al extremo 2
        if(index_begin > index_end){ # si los indices estan al reves se intercambian
          index_aux <- index_begin
          index_begin <- index_end
          index_end <- index_aux
        }
        structure1 <- paths_ext[k,index_begin:index_end] # se busca usando los extremos esa estructura en el ciclo k
        structure1_length <- length(structure1) # se toma su longitud
        structure2 <- paths_ext[k,index_end:(index_begin+n)] # se considera el camino complemento del primero
        structure2_length <- length(structure2) # se toma su longitud
        if(structure_length==structure1_length){ # si tienen longitudes iguales
          if(length(setdiff(structure, structure1))==0){ #y si tienen las mismas ciudades
            structure1_cost <- sum(costs_ext[k, index_begin:(index_end-1)]) # considera el costo
            if(structure1_cost < structure_cost){ # si es mas barato es posible hacer un swap
              exito <- exito + 1 # considera que llevas un exito
              structure_list[[exito]] <- structure1 # agregalo a la lista
              structure_cost_vector[exito] <- structure1_cost - structure_cost # agrega la utilidad 
              structure_index_list[[exito]] <- c(k, index_begin, index_end) # informacion de donde empieza y donde acaba
            }
          }
        }
        if(structure_length==structure2_length){ # se hace lo análogo con el camino complemento
          if(length(setdiff(structure, structure2))==0){
            structure2_cost <- sum(costs_ext[k,index_end:(index_begin+n-1)])
            if(structure2_cost < structure_cost){
              exito <- exito + 1
              structure_list[[exito]] <- structure2
              structure_cost_vector[exito] <- structure2_cost - structure_cost
              structure_index_list[[exito]] <- c(k, index_end, index_begin+n)
            }
          }
        }
      }
      # se incrementan el incio y fin y se revisan asi los n posibles caminos
      ini <- ini + 1
      end <- end + 1
    }
  }
  if(exito>0){
    index_min <- which.min(structure_cost_vector) # el numero de exito que sera reemplazado
    index_replace <- structure_index_list[[index_min]][1] # corresponde al ciclo numero k
    index_begin <- structure_index_list[[index_min]][2] # que comienza en la ciudad index_begin
    index_end <- structure_index_list[[index_min]][3] # termina en la ciudad index_end
    structure_replace <- structure_list[[index_min]] # la estructura a remplazarse
    costs_replace <- costs_ext[index_replace, index_begin:(index_end-1)]
    index_head <- index_matrix[cycle_index, structure_replace[1]]
    index_tail <- index_matrix[cycle_index, tail(structure_replace, 1)]
    if(length(index_head:index_tail) == length(structure_replace)){
      # En este caso se puede sustituir la estructura en el camino sin necesidad de cortarlo
      # Puede ser que haya que ponerlo tal y como esta o en reversa
      if(index_head > index_tail){
        structure_replace <- rev(structure_replace)
        costs_replace <- rev(costs_replace)
        aux <- index_head
        index_head <- index_tail
        index_tail <- aux  
      }
      paths[cycle_index, index_head:index_tail] <- structure_replace
      costs[cycle_index, index_head:(index_tail-1)] <- costs_replace
    }
    else{
      if(index_head < index_tail){
        structure_replace <- rev(structure_replace)
        costs_replace <- rev(costs_replace)
        aux <- index_head
        index_head <- index_tail
        index_tail <- aux  
      }
      index_cut <- which(structure_replace == cycle_index)
      structure_head <- structure_replace[1:index_cut]
      structure_tail <- structure_replace[-1:-(index_cut-1)]
      edges_costs <- costs_replace
      edges_costs_head <- edges_costs[1:(index_cut-1)]
      edges_costs_tail <- edges_costs[-1:-(index_cut-1)]
      index_begin <- index_tail + 1 # El primer indice que no es de la estructura
      index_end <- index_head-1 # El ultimo indice que no es de la estructura
      paths[cycle_index,] <- c(structure_tail, paths[cycle_index, index_begin:index_end], structure_head)
      costs[cycle_index,] <- c(edges_costs_tail, costs[cycle_index, (index_begin-1):index_end], edges_costs_head)
      print("Warning: this section of code is prone to error, it was programmed by an idiot")
    }
    for(i in 1:n){
      index_matrix[i,] <- sapply(1:n, function(j) index_function(i,j))
      paths_ext[i,] <-  c(paths[i,], paths[i,2:n])
      costs_ext[i,] <-  c(costs[i,], costs[i,])
    }
  }
}
```

```{r}
path_min_swap <- paths[cycle_index,]
cost_min_swap <- sum(costs[cycle_index,])
```

```{r}
cities_pos_df <- as.data.frame(cities_pos)
g1 <- TSP_plot(cities_pos_df, path_min_noswap, path_min_noswap) +  ggtitle("Sin Swapping")  + labs (x = cost_min_noswap, y = "")
g2 <- TSP_plot(cities_pos_df, path_min_swap, path_min_noswap) +  ggtitle("With Swapping")  + labs (x = cost_min_swap, y = "")
grid.arrange (g1, g2, nrow=1)
```