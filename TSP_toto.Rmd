---
title: "TSP_toto"
author: "Alfredo Carrillo"
date: "February 16, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(gridExtra)
```

# Functions
```{r}
# Define Euclidean distance funcion
dist_euclidean <- function(i, j){
  result <- (i-j)^2 %>% sum() %>% sqrt()
  return(result)
}
# Given set of coordiantes calculates euclidean distance and adds noice.
matrix_euclidean <- function(matrix_pos){
  matrix_dist <- matrix(integer(n^2), ncol = n)
  for(i in 1:(n-1)){
    i_vec <- matrix_pos[i,]
    for(j in (i+1):n){
      j_vec <- matrix_pos[j,]
      matrix_dist[i,j] <- dist_euclidean(i_vec, j_vec)  %>% round(2)
      matrix_dist[j,i] <- matrix_dist[i,j]
    }
  }
  return(matrix_dist)
}

# Hace simétrica la matrix
matrix_symmetric <- function(matrix){
  for(i in 1:(n-1)){
    for(j in (i+1):n){
        if(matrix[i,j] != matrix[j,i]){
          if(matrix[i,j] < matrix[j,i]){
            matrix[j,i] <- matrix[i,j]
          }
          else{
            matrix[i,j] <- matrix[j,i]
          }
        }
     }
  }
  return(matrix)
}

# Updates distance matrix when triangle Inequality is not satissfied
desigualdad_triangulo <- function(cities_dist)
  for(i in 1:(n-1)){
    for(j in (i+1):n){
      distancia_minima <- cities_dist[i,j]
      set <- setdiff(1:n, c(i,j))
      for(k in set){
        distancia_indirecta <- cities_dist[i,k] + cities_dist[k,j]
        if(distancia_indirecta < distancia_minima){
          distancia_minima <- distancia_minima
        }
      }
      cities_dist[i,j] <- distancia_minima
      cities_dist[j,i] <- distancia_minima
    }
    return(cities_dist)
  }
TSP_plot <- function(cities_pos_df, camino_heuristica, camino_heuristica_original){
  n <- nrow(cities_pos_df)
  g <- ggplot(cities_pos_df, aes(x = V1, y = V2)) + geom_point() + theme_bw() + geom_text(aes(label=c(1:n)), hjust=0, vjust=0)
  if(all(!camino_heuristica==0)){
    m <- n
  }
  else{
   m <- min(which(camino_heuristica==0))-2 
  }
  for(i in 1:m){
     i_vec <- flatten_dbl(cities_pos_df[camino_heuristica[i],])
     j_vec <- flatten_dbl(cities_pos_df[camino_heuristica[i+1],])
     if(camino_heuristica[i] == camino_heuristica_original[i]){
        g <- g + geom_segment(x = i_vec[1], xend = j_vec[1], y = i_vec[2], yend = j_vec[2], color="black")
     }
     else{
       g <- g + geom_segment(x = i_vec[1] , xend = j_vec[1], y = i_vec[2], yend = j_vec[2], color="red") 
     }
  }
  return(g)
}

index_function <- function(i,j){
  return(which(paths[i,]==j)[1])
}
```

# Hyper parameters
```{r}
set.seed(11212)
proportion_edges <- 1/2 # Each node will only have this proportion of neighbors with respect the n neighbors
greedy <- 3 # When a node has this number of neighbors then it adds to the path regardless of the cost
```

# Main
```{r}
######################################## LEER ARCHIVO
# instancia <- read_table2("~/Desktop/Tesis_Maestria/tesis_maestria/d198.tsp", skip = 4)
# n <- nrow(instancia)
# cities_pos <- instancia[2:(n-1),2:3]
# n <- n-2
######################################## GENERAR matrix ALEATORIA
n <- 75
cities_pos <- matrix(runif(2*n), ncol = 2) # Generate coordinates of n neighbors randomly
cities_pos <- round(1000*(cities_pos)) # Round to integers
#################################################################
cities_pos <- as.matrix(cities_pos)
colnames(cities_pos) <- c("V1", "V2")
cities_dist_original <- matrix_euclidean(cities_pos) # Generate distance matrix
cities_dist <- cities_dist_original # For last iteration, save original values
```

```{r}
# Eliminate all but the first kth nearest edges for each node.
number_neighbors <- floor(n*proportion_edges) # Number of the first kth neighbors, the rest edges will get eliminated
# Eliminate all but the first kth nearest edges for each node.
for(i in 1:n){
  kth_near <- (cities_dist_original[i,] %>% sort())[number_neighbors]
  for(j in 1:n){
      if(cities_dist_original[i,j] > kth_near){
        cities_dist[i,j] <- Inf
      }
   }
}

# It is possible that the resulting matrix is not symmetric because there is no symmetry in the fact that 
# the kth neighbor v2 for a v1 node might not be the kth neighbor v1 for v2.
cities_dist <- matrix_symmetric(cities_dist)


# We define a list that has the neighbors of each node. Because each node can have different amount of neighbors a matrix
# is not an appropriate structure.
neighbors_list <- list()
for(i in 1:n){
  neighbors_list[[i]] <- which(as.logical((cities_dist[i,] < Inf)*(cities_dist[i,] > 0) %>% as.integer()))
}
# Estricturas a usar
paths <- matrix(integer((n+1)*n), nrow = n) # The Paths starting at each node. In each row we try to form a cycle.
paths[,c(1,(n+1))] <- 1:n
costs <- matrix(integer(n^2), nrow = n) # The cost of traveling from [i,j] to [i,j+1]
# Vector con numero de neighbors
degree_neighbors <- sapply(1:n, function(i){neighbors_list[[i]] %>% length()}) #Number of neighbors of each node
degree_neighbors_list <- list() # For each cycle we need to keep control of how many neighbors are left. We define a list.
for(i in 1:n){
  degree_neighbors_list[[i]] <- degree_neighbors
}
```

#Iteraciones
```{r}
# Primero generamos un cycle hamiltoniano para cada nodo.
m <- n-1 # Si se quiere ver como se ve el camino en la m-ésima iteracion se puede ajustar, sino dejar m = n-1
for(num_iter in 1:m){
    for(i in 1:n){
      city_current <- paths[i, num_iter]
      # Se calculan las ciudades que no se han visitado y se guardan como vector
      cities_neighbors_to_go <- setdiff(neighbors_list[[city_current]], paths[i, 1:num_iter])
      if(length(cities_neighbors_to_go) > 0){
        # Se guardan en un vector solo los grados de los correspondientes nodos por visitar
        degree_neighbors_to_go <- degree_neighbors_list[[i]][cities_neighbors_to_go]
        # Se calcula un valor booleano que previene que nos olvidemos de un nodo. Si existe un nodo con pocos
        # vecinos hay que visitarlo inmediatamente, sino, conviene visitar el más proximo.
        immediate_neighbors <- degree_neighbors_to_go <= greedy
        if(all(!immediate_neighbors)){
          # En caso de que todos los nodos tengan multiples vecinos calcular el mas proximo
          city_distances <- cities_dist_original[city_current, cities_neighbors_to_go]
          dist_min <- min(city_distances)
          city_min <- cities_neighbors_to_go[which.min(city_distances)]
        }
        else{
        # En caso de que haya que visitar uno inmediatamente entonces añadirlo
          city_index_next <- which.min(degree_neighbors_to_go)
          city_min <- cities_neighbors_to_go[city_index_next]
          dist_min <- cities_dist_original[city_current, city_min]
       }
       # Todos los vecinos que tengan asociado a la ciudad que se visita se les resta un grado
       degree_neighbors_list[[i]][cities_neighbors_to_go] <- degree_neighbors_list[[i]][cities_neighbors_to_go] - 1
       # Se actualiza el grado de la ciudad actual a 0.
       degree_neighbors_list[[i]][city_current] <- 0
       # Se actualiza la matriz de costo.
       costs[i, num_iter] <- dist_min
       paths[i, num_iter+1] <- city_min
      }
      else{
        costs[i, num_iter] <- Inf
        paths[i, num_iter+1] <- paths[i, num_iter] 
      }
  }
}
if(m == n-1){
  costs[1:n, n]  <- sapply(1:n, function(i){cities_dist_original[paths[i, n], i]})
}
costs_cycles <- sapply(1:n, function(i){sum(costs[i,])})
cycle_index <- which.min(costs_cycles)
path_min_noswap <- paths[cycle_index,]
cost_min_noswap <- costs_cycles[cycle_index]
```

```{r}
index_matrix <- matrix(0L, nrow = n, ncol = n)
paths_ext <- matrix(0L, nrow = n, ncol = 2*n)
costs_ext <- matrix(0L, nrow = n, ncol = 2*n)
for(i in 1:n){
  index_matrix[i,] <- sapply(1:n, function(j) index_function(i,j))
  paths_ext[i,] <-  c(paths[i,], paths[i,2:n])
  costs_ext[i,] <-  c(costs[i,], costs[i,])
}
```

```{r}
exito <- 1
while(exito>0){
  exito <- 0
  structure_list <- list()
  structure_index_list <- list()
  structure_cost_vector <- c()
  for(len in 1:(n-1)){
    ini <- 1
    end <- len+1
    for(path in 1:n){
      structure <- paths_ext[cycle_index, ini:end]
      structure_cost <- sum(costs_ext[cycle_index, ini:(end-1)])
      structure_length <- length(structure)
      extreme1 <- structure[1]
      extreme2 <- tail(structure, 1)
      for(k in setdiff(1:n, cycle_index)){
        index_begin <- index_matrix[k,extreme1]
        index_end <- index_matrix[k,extreme2]
        if(!is.na(index_begin) && !is.na(index_end)){
          if(index_begin > index_end){
            index_aux <- index_begin
            index_begin <- index_end
            index_end <- index_aux
          }
          structure1 <- paths_ext[k,index_begin:index_end]
          structure1_length <- length(structure1)
          structure2 <- paths_ext[k,index_end:(index_begin+n)]
          structure2_length <- length(structure2)
          if(structure_length==structure1_length){
            if(length(setdiff(structure, structure1))==0){
              structure1_cost <- sum(costs_ext[k, index_begin:(index_end-1)])
              if(structure1_cost < structure_cost){
                exito <- exito + 1
                structure_list[[exito]] <- structure1
                structure_cost_vector[exito] <- structure1_cost - structure_cost
                structure_index_list[[exito]] <- c(k, index_begin, index_end)
              }
            }
          }
          if(structure_length==structure2_length){
            if(length(setdiff(structure, structure2))==0){
              structure2_cost <- sum(costs_ext[k,index_end:(index_begin+n-1)])
              if(structure2_cost < structure_cost){
                exito <- exito + 1
                structure_list[[exito]] <- structure2
                structure_cost_vector[exito] <- structure2_cost - structure_cost
                structure_index_list[[exito]] <- c(k, index_end, index_begin+n)
              }
            }
          }
        }
      }
      ini <- ini + 1
      end <- end + 1
    }
  }
  if(exito>0){
    index_min <- which.min(structure_cost_vector)
    index_replace <- structure_index_list[[index_min]][1]
    index_begin <- structure_index_list[[index_min]][2]
    index_end <- structure_index_list[[index_min]][3]
    structure_replace <- structure_list[[index_min]]
    costs_replace <- costs_ext[index_replace, index_begin:(index_end-1)]
    ini <- index_matrix[cycle_index, structure_replace[1]]
    end <- index_matrix[cycle_index, tail(structure_replace, 1)]
    if(ini > end){
      aux <- ini
      ini <- end
      end <- aux
      structure_replace <- rev(structure_replace)
      costs_replace <- rev(costs_replace)
    }
    if(length(ini:end) == length(structure_replace)){
      paths[cycle_index,ini:end] <- structure_replace
      costs[cycle_index, ini:(end-1)] <- costs_replace
    }
    else{
      edges_costs <- costs_replace
      index_cut <- which(structure == cycle_index)
      structure_head <- structure[1:index_cut]
      structure_tail <- structure[-1:-(index_cut-1)]
      edges_costs_head <- edges_costs[1:(index_cut-1)]
      edges_costs_tail <- edges_costs[-1:-(index_cut-1)]
      begin_index <- length(structure_head) + 1
      end_index <- n+1 - length(structure_tail)
      paths[cycle_index,] <- c(structure_tail, paths[cycle_index,begin_index:end_index], structure_head)
      begin_index <- length(structure_head)
      costs[cycle_index,] <- c(edges_costs_tail, costs[cycle_index, begin_index:end_index], edges_costs_head)
      print("Warning")
    }
    for(i in 1:n){
      index_matrix[i,] <- sapply(1:n, function(j) index_function(i,j))
      paths_ext[i,] <-  c(paths[i,], paths[i,2:n])
      costs_ext[i,] <-  c(costs[i,], costs[i,])
    }
  }
}
```

```{r}
path_min_swap <- paths[cycle_index,]
cost_min_swap <- sum(costs[cycle_index,])
```

```{r}
cities_pos_df <- as.data.frame(cities_pos)
g1 <- TSP_plot(cities_pos_df, path_min_noswap, path_min_noswap) +  ggtitle("Sin Swapping")  + labs (x = cost_min_noswap, y = "")
g2 <- TSP_plot(cities_pos_df, path_min_swap, path_min_noswap) +  ggtitle("With Swapping")  + labs (x = cost_min_swap, y = "")
grid.arrange (g1, g2, nrow=1)
```